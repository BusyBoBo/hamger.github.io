<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[PHP字符串操作]]></title>
      <url>%2F2017%2F04%2F09%2FPHP%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[定义字符串PHP中定义字符串有三种方式(其中单引号和双引号的区别请详见这里)： 单引号 $hello = &#39;hello world&#39;; 双引号 $hello = &quot;hello world&quot;; heredoc语法结构123$hello = &lt;&lt;&lt;TAGhello worldTAG; 操作字符串 方法 功能 . 连接字符串 trim()/rtrim()/ltrim() 去除（两边/右边/左边）空格 strlen()/mb_strlen() 获取字符串/中文字符串长度 substr($str,start,howmany） 截取字符串 md_substr($str,start,howmany,’utf8’） 截取中文字符串 strpos(要处理的字符串, 要定位的字符串, [定位的起始位置) 返回要定位的字符串索引 str_replace(被替换的字符串, 替换的字符串, 被搜索的字符串, [替换进行计数]) 替换字符串（区分大小写） sprintf(格式, 要转化的字符串) 格式化字符串 implode(分隔符[可选], 数组) 把数组元素合并为一个字符串 explode(分隔符[可选], 字符串) 把一个字符串分隔为数组元素 addslashes() 转义字符串 12345678910111213$str = "what's your name?";echo addslashes($str); // what\'s your name?$arr = array('Hello', 'World!');$result = implode(' ', $arr);print_r($result); // Hello World!$result2 = explode(' ', $result);print_r($result2); // Array ( [0] =&gt; Hello [1] =&gt; World! )$str2 = '99.9';$result3 = sprintf('%01.2f', $str2);echo $result3; // 99.90]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pug模板语法]]></title>
      <url>%2F2017%2F04%2F07%2Fpug%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[pug 是 HTML 的模板引擎，原名 jade ，大大简化了 HTML 代码的书写，并且增加了许多功能，代码之间的嵌套关系是统一通过 空格 或者 tab 来实现的， 不能两者混合用 ，并且 1个tab不等于4个空格 ，请务必先记住这一点。 基础pug 长这样：12345678910111213141516171819202122doctype html head meta(charset=&apos;utf-8&apos;) title my resume style. body&#123;background-color:#ABFDBA&#125; script. var name = &apos;scoot&apos; body - var jade = &#123;source:&apos;jade&apos;,level:&apos;high&apos;&#125; h2 a frondend enginner #&#123;jade.level&#125; p | Alice | Tom | Hairen a(href=&apos;www.baidu.com&apos;) baidu .skills haha div.program lalla ul#fruit.fruit li aaa li bbb div: a hahhah 以上代码等价与：12345678910111213141516171819202122&lt;!DOCTYPE html &gt;&lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;my resume &lt;/title&gt; &lt;style&gt;body&#123;background-color:#ABFDBA&#125;&lt;/style&gt; &lt;script&gt;var name = 'scoot' &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;a frondend enginner high&lt;/h2&gt; &lt;p&gt; Alice Tom Hairen &lt;a href="www.baidu.com"&gt;baidu &lt;/a&gt; &lt;/p&gt; &lt;div class="skills"&gt; haha&lt;/div&gt; &lt;div class="program"&gt; lalla&lt;/div&gt; &lt;ul class="friuts" id="fruit"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;a&gt;hahhah &lt;/a&gt;&lt;/div&gt;&lt;/body&gt; 符号 符号 含义 . 表示之后的内容翻译为纯文本 : 表示嵌套关系，不需要换行 &#124; 表示之后的内容翻译为纯文本，不识别HTML标签 // 注释，在编译出来的html中显示 //- 注释，在编译出来的html中不显示 - 后接 js 代码 #{变量} 转义插值 !{变量} 非转义插值 逻辑操作123456789101112- var list = [&apos;one&apos;, &apos;two&apos;,&apos;three&apos;] - for (k in list) p= list[k] if list if (list.length &gt; 2) p lists more than two else if (list.length &gt;= 1) p two lists or one list else p no list else p no list 输出1234&lt;p&gt;one&lt;/p&gt;&lt;p&gt;two&lt;/p&gt;&lt;p&gt;three&lt;/p&gt;&lt;p&gt;lists more than two &lt;/p&gt; Mixinminix可以理解为就是在定义一个函数，然后用+来调用函数，函数可以进行嵌套。1234567mixin student(name,course) p #&#123;name&#125; studing #&#123;course&#125;mixin group(obj) h2 my name is #&#123;obj.name&#125; +student(obj.name,obj.course)h1 +group(&#123;name:&apos;tom&apos;,course:&apos;jade&apos;&#125;) 输出：1234&lt;h1&gt; &lt;h2&gt;my name is tom&lt;/h2&gt; &lt;p&gt;tom studing jade&lt;/p&gt;&lt;/h1&gt; 模板继承 关键词 描述 block 占位符，通过其实现子模板的追加和替换 extends 继承，子模板继承父模板中的代码 append 在子模板中向后追加内容 prepend 在子模板中向前追加内容 include 引入文件，并将其中的代码放到模板中 实例例如，父模板如下：12345678910// layout.jadedoctype htmlhtml head block scripts script(src=&apos;jquery.js&apos;) block styles body block content p there&apos;s no content here 现在有一个子模板继承了上述父模板1234567891011121314// page1.jade（假设和layout.jade相同路径）extends layout // .jade扩展名可以省略block scripts script(src=&apos;react.js&apos;)append scripts script(src=&apos;underscore.js&apos;)prepend scripts script(src=&apos;vue.js&apos;) block content //内容被替换为空 输出如下，留意脚本顺序：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script src="react.js"&gt;&lt;/script&gt; &lt;script src="underscore.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; includeinclude一般用来引入模板间可以复用的代码（比如头部和尾部），实现代码的去冗余。1234567doctype htmlhtml head style(type=&apos;text/css&apos;) include style.css body include content.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式中加变量]]></title>
      <url>%2F2017%2F04%2F04%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%8A%A0%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[当我们定义一个字符串、数组、对象等等的时候，我们习惯用字面量来定义，例如:123var s = "string";var a = [1,2];var o = &#123;&#125;; 当需要加入变量时也十分简单：1234var v = "bl";var s = "string" + v; //"stringbl"var a = [1,v]; //[1,"bl"]var o = &#123;first : v&#125;; //&#123;first : "bl"&#125; 但是如果是正则的字面量，就不能像上面这样加入变量了。此时应该采用构造函数的形式来加入变量：12var v = "bl";var re = new RegExp("^\\d+" + v + "$","gim"); // re为/^\d+bl$/gim]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下命令行]]></title>
      <url>%2F2017%2F04%2F02%2FMac%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[本博文记录自己用到过 Mac 命令行，会保持更新。 关于man命令在命令行中输入 man command-name 会返回一个该条命令的使用指南，非常详细。使用指南往往很长，可以使用 ▲（上箭头）或 ▼（下箭头）来上下移动，使用空格键来翻页，输入/和关键字来搜索，按 Q 退出。 目录操作 命令 描述 用法 mkdir 创建一个目录 mkdir dir1 rmdir 删除一个空目录 rmdir dir1 rm -r 删除一个目录 rm -r dir1 mvdir 移动/重命名一个目录 mvdir dir1 dir2 cd 切换到指定目录 cd dirPath ls 显示目录内容 ls (dir1) pwd 显示目录路径 pwd 文件操作 命令 描述 用法 &gt; 创建/覆盖文件 &gt; file1 &gt;&gt; 创建/追加文件 &gt;&gt; file1 cat 显示文件内容 cat flie1 more 分屏显示文件内容 more file1 cp 复制文件或目录 cp file1 file2 rm 删除一个文件 rm file1 mv 移动/重命名一个文件 mv file1 file2 flie 显示文件类型 file fiel1 open 用默认程序打开文件 open fiel1 nano 默认编辑器打开文件 nano fiel1 vim 用Vim编辑文件 vim file1 在Vim中的命令 命令 描述 a 在光标下一个字符处插入 gg 将光标快速移动到文件首 G 将光标快速移动到文件尾 0(零) 将光标快速移动到行首 $ 将光标快速移动到行尾 /内容 查找内容，按n跳到下一项 u 撤销，回到上一步操作 :行号 定位到指定行 :w 保存 :q 未保存直接退出 :wq 或 :x 保存并退出 :wq! 或 :x! 强制保存并退出 :w! 强制保存 :q! 强制退出 :syntax on/off 开启/关闭语法高亮 其他操作 命令 描述 用法 sudo 进入管理员模式(‘super user do’) sudo -s exit 退出管理员模式 exit ps 显示进程 ps -u kill 终止进程 kill -9 30142 clear 或 ctrl+L 清屏 clear alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del find 查找 find -name ‘*.html’ history 列出最近执行过的（n条）命令 history (n) chown 更改某个目录或文件的用户名和用户组 chown root:root file1/dir1 chmod 修改某个目录或文件的访问权限 chmod [who] [+ &#124;-&#124;=] [mode] file1/dir1 who 列出当前登入的所有用户 who whoami 列出当前操作的用户 whoami chmod用来修改某个目录或文件的访问权限。语法：chmod [who] [+|-|=] [mode] file1/dir1命令中各选项的含义为：操作对象 who 可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。 g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。 a 表示“所有（all）用户”。它是系统默认值。 操作符号可以是： + 添加某个权限。 - 取消某个权限。 = 赋予给定权限并取消其他所有权限（如果有的话）。 设置 mode 所表示的权限可用下述字母的任意组合： r 可读。 w 可写。 x 可执行。 X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。 s 在文件执行时把进程的属主或组ID置为该文件的文件属主。 t 保存程序的文本到交换设备上。 u 与文件属主拥有一样的权限。 g 与和文件属主同组的用户拥有一样的权限。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS跨域请求]]></title>
      <url>%2F2017%2F03%2F30%2FJS%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
      <content type="text"><![CDATA[跨域是由浏览器的同源策略引起的，即不同源（协议,域名,端口中其中有一个不同）的js是不能读取对方的资源的。限制跨域是浏览器的行为，而不是JS的行为。要实现跨域请求，解决方法大致分为两类： 一类是Hack，比如通过 title , navigation 等对象传递信息，JSONP可以说是一个最优秀的Hack。 另一类是HTML5支持，一个是 Access-Control-Allow-Origin 响应头，一个是 window.postMessage 。 document.domain原理：相同主域名不同子域名下的页面，可以设置 document.domain 让它们同域。限制：同域document提供的是页面间的互操作，需要载入iframe页面。 JSONP原理：&lt;script&gt;是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数。限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法。跨域URL返回的脚本不仅包含数据，还包含一个回调：123456// URL: http://b.a.com/foovar data = &#123; foo: 'bar', bar: 'foo'&#125;;callback(data); 在主站http://a.com中，可以这样来跨域获取http://b.a.com的数据：123456// URL: http://a.com/foovar callback = function(data)&#123; // 处理跨域请求得到的数据&#125;;var script = $('&lt;script&gt;', &#123;src: 'http://b.a.com/bar'&#125;);$('body').append(script); 其实jQuery已经封装了JSONP的使用，我们可以这样来：123$.getJSON( "http://b.a.com/bar?callback=callback", function( data )&#123; // 处理跨域请求得到的数据&#125;); CORS原理：服务器设置 Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。限制：浏览器需要支持HTML5， 可以支持POST，PUT等方法。前面提到的跨域手段都是某种意义上的Hack， HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题。 window.postMessage原理：HTML5允许窗口之间发送消息。限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS原生DOM操作]]></title>
      <url>%2F2017%2F03%2F29%2FJS%E5%8E%9F%E7%94%9FDOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[jQuery 用久了，原生JS操作 DOM 的方法就容易忘，在此好好归纳一下原生的常用方法。 创建元素 创建元素：document.createElement() 1234var div = document.createElement("div");div.id = "myDiv";div.className = "div1";document.body.appendChild(div); 创建文本节点 ：document.createTextNode() 12var node = document.createTextNode("我是文本节点"); document.body.appendChild(node); 节点关系12345&lt;div id="div0"&gt; &lt;div id="div1" name="nameone"&gt;1&lt;/div&gt; &lt;div id="div2" class="div2"&gt;2&lt;/div&gt; &lt;div id="div3"&gt;3&lt;/div&gt;&lt;/div&gt; 父节点：parentNode 12var child2 = document.getElementById("div2");var parent = child2.parentNode; 子节点：children、childNodes children 只读属性，返回节点的子节点集合，不包括文本节点，只有元素节点，推荐使用。childNodes 只读属性，返回节点的子节点集合，包括元素节点和文本节点(换行，空格也算)。 该集合为即时更新的集合（live collection），即对节点元素的任意修改都会立即反映到结果里。1234567var allChilds = parent.childNodes;console.log(allChilds.length) // 返回7，IE返回3 var nodeAdd = document.createElement("div");var textAdd = document.createTextNode("这是添加的文本节点");nodeAdd.appendChild(textAdd);parent.appendChild(nodeAdd);console.log(allChilds.length);// 返回8，IE返回4 兄弟节点：nextSibling、previousSibling node.nextSibling || node.nextElementSibling 下一个兄弟节点node.previousSibling || node.previousElementSibling 上一个兄弟节点注意，前者包含文本节点和元素节点，后者只包含元素节点，后者IE9+支持 12var next = child2.nextSibling;var previous = child2.previousSibling; 第一个或最后一个子节点：firstChild、lastChild 12var first = parent.firstChild; var last = parent.lastChild; 节点操作 添加节点：appendChild() appendChild()用于向childNodes列表的末尾添加一个节点，并且返回这个新增的节点。如果传入到appendChild()里的节点已经是文档的一部分了，那结果就是将节点从原来的位置转移到新位置，任何一个节点不能同时出现在文档中的多个位置。 插入节点：insetBefore() insetBefore()可以将节点插入到某个特定的位置。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是null，则与appendChild()执行相同的操作。123var returnNode = someNode.insetBefore(newNode, null);var returnNode = someNode.insetBefore(newNode, someNode.firstChild);var returnNode = someNode.insetBefore(newNode, someNode.lastChild); 替换节点： replaceChild() replaceChild()接受两个参数：要插入的节点和要被替换的节点。被替换的节点将由这个方法返回并从文档中被移除，同时由要插入的节点占据其位置。 删除节点：removeChild() 该方法接受一个参数，即要移除的节点，同时该方法返回被移除的节点。只能是一个节点，不能是一组节点。 克隆节点：cloneNode(true/false) 返回节点的一个副本。参数表示是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身，文本、换行、空格等不会被复制。默认为true。克隆一个元素节点会拷贝它所有的属性以及属性值,包括了属性上绑定的事件(比如onclick=”alert(1)”),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件。注意:为了防止一个文档中出现两个ID相同的元素,使用cloneNode()方法克隆的节点在需要时应该指定新ID值。12var cloneHtml = child2.cloneNode(true);document.body.appendChild(cloneHtml); 元素选择 querySelector()、querySelectorAll() (IE8+) querySelector 返回相匹配的 第一个 Element节点。如果没有相匹配的，则返回null。querySelectorAll 返回相匹配的 所有 Element节点列表，如果没有相匹配的，则返回一个空节点列表。12var special = document.querySelectorAll( "p.warning, p.note" );var el = document.querySelector( "#main, #basic, #exclamation" ); 执行上面的代码后，el包含了文档中元素的ID是main、basic 或 exclamation的 所有元素中的第一个元素 。 getElementsBy系列 1234var element1 = document.getElementById("div0");var element2 = document.getElementsByClassName("div2");var element3 = document.getElementsByTagName("div");var element4 = document.getElementsByName("nameone"); 属性操作 Attribute系列 123456child2.setAttribute("class", "new_class");child2.removeAttribute("class");var attr = child2.getAttribute("class");console.log(attr); // nullvar hasName = child2.hasAttribute("name");console.log(hasName); // true 自定义属性 HTML5 中data-*可以给指定元素添加自定义的属性。1&lt;div id="div4" data-aa="11"&gt; 利用div4.dataset可以获得一个DOMStringMap，包含了元素的所有data-*。使用div4.dataset.aa返回值为11。通过设置div4.dataset.bb = &quot;22&quot;就可以添加一个新的自定义属性。不兼容则使用getAttribute和setAttribute。123456789var div4 = document.getElementById("div4");var a = null;if (div4.dataset) &#123; a = div4.dataset.aa; div4.dataset.bb = "22";&#125; else &#123; a = div4.getAttribute("data-aa"); div4.setAttribute("data-bb", "22");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面跳转方式]]></title>
      <url>%2F2017%2F03%2F29%2F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[前端工作有很多地方需要页面跳转，有很多种实现方法。 HTML标签一般形式上可以用&lt;a&gt;&lt;/a&gt;、&lt;button&gt;&lt;/button&gt;、&lt;input/&gt;：123&lt;a href="链接"&gt;GO&lt;/a&gt;&lt;button onclick="window.location.href='链接'"&gt;GO&lt;/button&gt;&lt;input type="button" value="GO" onclick="location.href='链接'"&gt; JS跳转页面代码本页跳转12345window.location.href = '链接';window.location = '链接';location.href = '链接';location = '链接';top.location = '链接'; 新页跳转12window.open('链接');open('链接'); 或者在HTML标签中添加target=&quot;_blank&quot;:1&lt;a href="链接" target="_blank"&gt;GO&lt;/a&gt; 历史跳转12&lt;a href="history.go(-1)"&gt;返回上一步&lt;/a&gt;&lt;a href="window.history.back()"&gt;返回上一步&lt;/a&gt; 选择框跳转12345678&lt;input type="button" value="GO" onclick="logout()"&gt;&lt;script language="javascript"&gt;function logout() &#123; if (confirm("你确定要跳转页面吗？"))&#123; window.location = "https://hamger.github.io/"; &#125;&#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text3快捷键和插件]]></title>
      <url>%2F2017%2F03%2F28%2FSublime-Text3%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[Sublime Text3 是一款很好用的编辑器，想要优雅地使用它，知道部分快捷键和插件是必须的。 常用快捷键 快捷键 描述 control + - 回到上一个光标 control + shift + - 回到下一个光标 control + cdm + ↑/↓ 移动当前行代码 control + option + t 交换选中的两部分代码 cmd + option + [ 折叠选中的代码 cmd + option + ] 展开选中的代码 shift + cmd + p 打开命令面板 control + ` 打开控制台 cmd + n 新建标签 cmd + 1/2/3… 标签切换 cmd + option + 2 分成两屏 cmd + delelte 删除本行光标前的所有字符 cmd + shift + ↑/↓ 选中光标上下代码 cmd + f 查找 option + cmd + f 查找替换 cmd + t 跳转到指定文件 control + g 跳转到指定行 cmd + r 跳转到指定函数 cmd + l 选中当前行 cmd + / 注释当前行或注释选中代码 cmd + option + / 产生注释代码或注释选中代码 cmd + k + b 开关侧边栏 包管理器下载插件之前，你需要先添加 Package Control安装过程: 使用快捷键 control + ` 或者菜单栏选择 View &gt; Show Console Sublime Text3 在控制台输入 1import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404&apos; + &apos;e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) Sublime Text2 在控制台输入 1import urllib2,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404&apos; + &apos;e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 推荐插件 插件 描述 Emmet 大名鼎鼎，大大提高开发效率 BracketHighlighter 高亮显示匹配的括号、引号和标签 HTML-CSS-JS Prettify node.js环境下，代码格式化(cmd + shift + h) ColorPicker 调色盘(cmd+shift+c) SideBarEnhancements 侧边栏增强 sublime tmpl 快速模板(control+option+h/c/j/p)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP单双引号区别]]></title>
      <url>%2F2017%2F03%2F27%2FPHP%E5%8D%95%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[单引号内字段不进行解释，直接输出。 双引号内字段会经过编译器解释，然后再当作HTML代码输出。 双引号内部变量会解析,单引号则不解析。1234$abc = 'my name is Tom';echo $abc; //结果是:my name is Tomecho '$abc'; //结果是:$abcecho "$abc"; //结果是:my name is Tom 建议 PHP 引号使用原则： 纯字符串最外层用单引号。 包含变量时最外层用双引号。 包含特殊符号(如换行符\n)时最外层用双引号。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础3]]></title>
      <url>%2F2017%2F03%2F27%2FPHP%E5%9F%BA%E7%A1%803%2F</url>
      <content type="text"><![CDATA[面向对象12345678910111213141516171819202122232425262728293031323334&lt;?php class Site &#123; /* 成员变量 */ var $url; var $title; /* 成员函数 */ function setUrl($par)&#123; $this-&gt;url = $par; &#125; function getUrl()&#123; echo $this-&gt;url; &#125; function setTitle($par)&#123; $this-&gt;title = $par; &#125; function getTitle()&#123; echo $this-&gt;title; &#125; &#125; $google = new Site; // 调用成员函数，设置标题和URL $google-&gt;setTitle( "Google 搜索" ); $google-&gt;setUrl( 'www.google.com' ); // 调用成员函数，获取标题和URL $google-&gt;getTitle(); $google-&gt;getUrl(); ?&gt; 继承PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承，格式如下：123class Child extends Parent &#123; // 代码部分&#125; 重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 访问控制PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。类属性如果用 var 定义，则被视为公有。类方法如果没有设置这些关键字，则默认为公有。 public（公有）：公有的类成员可以在任何地方被访问。 protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。 private（私有）：私有的类成员则只能被其定义所在的类访问。 接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。1234567891011121314151617181920212223242526&lt;?php// 声明一个'iTemplate'接口interface iTemplate&#123; public function setVariable($name, $var); public function getHtml($template);&#125;// 实现接口class Template implements iTemplate&#123; private $vars = array(); public function setVariable($name, $var) &#123; $this-&gt;vars[$name] = $var; &#125; public function getHtml($template) &#123; foreach($this-&gt;vars as $name =&gt; $value) &#123; $template = str_replace('&#123;' . $name . '&#125;', $value, $template); &#125; return $template; &#125;&#125; 抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。定义为抽象的类不能被实例化。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。12345678910111213&lt;?phpabstract class AbstractClass&#123; // 强制要求子类定义这些方法 abstract protected function getValue(); abstract protected function prefixValue($prefix); // 普通方法（非抽象方法） public function printOut() &#123; print $this-&gt;getValue() . PHP_EOL; &#125;&#125;?&gt; static 关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。静态属性不可以由对象通过 -&gt; 操作符来访问。12345678910111213&lt;?phpclass Foo &#123; public static $my_static = 'foo'; public function staticValue() &#123; return self::$my_static; &#125;&#125;print Foo::$my_static; // 'foo'$foo = new Foo();print $foo-&gt;staticValue(); // 'foo'?&gt; Final 关键字PHP5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。 调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。123456789101112131415161718192021222324&lt;?phpclass BaseClass &#123; function __construct() &#123; print "BaseClass 类中构造方法" . PHP_EOL; &#125;&#125;class SubClass extends BaseClass &#123; function __construct() &#123; parent::__construct(); // 子类构造方法不能自动调用父类的构造方法 print "SubClass 类中构造方法" . PHP_EOL; &#125;&#125;class OtherSubClass extends BaseClass &#123; // 继承 BaseClass 的构造方法&#125;// 调用 BaseClass 构造方法$obj = new BaseClass();// 调用 BaseClass、SubClass 构造方法$obj = new SubClass();// 调用 BaseClass 构造方法$obj = new OtherSubClass(); 输出如下：1234BaseClass 类中构造方法BaseClass 类中构造方法SubClass 类中构造方法BaseClass 类中构造方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础2]]></title>
      <url>%2F2017%2F03%2F27%2FPHP%E5%9F%BA%E7%A1%802%2F</url>
      <content type="text"><![CDATA[命名空间PHP 命名空间(namespace)是在PHP 5.3中加入的，可以解决以下两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称创建一个别名（或简短）的名称，提高源代码的可读性。 定义命名空间默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。命名空间通过关键字namespace 来声明。可以在同一个文件中定义不同的命名空间代码。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括 空白符 都不能出现在命名空间的声明之前。1234567891011121314&lt;?phpdeclare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码namespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\connect();echo MyProject\Connection::start();&#125;?&gt; 以下代码会出现语法错误：1234&lt;html&gt;&lt;?phpnamespace MyProject; // 命名空间前出现了“&lt;html&gt;”会致命错误 - 命名空间必须是程序脚本的第一条语句!?&gt; 子命名空间与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义：12345678&lt;?phpnamespace MyProject\Sub\Level; //声明分层次的单个命名空间const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function Connect() &#123; /* ... */ &#125;?&gt; 上面的例子创建了常量 MyProject\Sub\Level\CONNECT_OK，类 MyProject\Sub\Level\Connection 和函数 MyProject\Sub\Level\Connect。 别名/导入PHP 命名空间支持 有两种使用别名或导入方式：为类使用别名、为命名空间使用别名。注意PHP不支持导入函数或常量。12345678910111213141516&lt;?phpnamespace foo;use My\Full\Classname as Another;// 下面的例子与 use My\Full\NSname as NSname 相同use My\Full\NSname;// 导入一个全局类use \ArrayObject;$obj = new namespace\Another; // 实例化 foo\Another 对象$obj = new Another; // 实例化 My\Full\Classname 对象NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象// 如果不使用 "use \ArrayObject" ，则实例化一个 foo\ArrayObject 对象?&gt; 后备全局函数/常量在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。 类名称总是解析到当前命名空间中的名称。因此在访问不包含在命名空间中的类名称时，必须使用完全限定名称。 对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。 命名空间顺序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace A;use B\D, C\E as F;// 函数调用foo(); // 首先尝试调用定义在命名空间"A"中的函数foo() // 再尝试调用全局函数 "foo"\foo(); // 调用全局空间函数 "foo" my\foo(); // 调用定义在命名空间"A\my"中函数 "foo" F(); // 首先尝试调用定义在命名空间"A"中的函数 "F" // 再尝试调用全局函数 "F"// 类引用new B(); // 创建命名空间 "A" 中定义的类 "B" 的一个对象 // 如果未找到，则尝试自动装载类 "A\B"new D(); // 使用导入规则，创建命名空间 "B" 中定义的类 "D" 的一个对象 // 如果未找到，则尝试自动装载类 "B\D"new F(); // 使用导入规则，创建命名空间 "C" 中定义的类 "E" 的一个对象 // 如果未找到，则尝试自动装载类 "C\E"new \B(); // 创建定义在全局空间中的类 "B" 的一个对象 // 如果未发现，则尝试自动装载类 "B"new \D(); // 创建定义在全局空间中的类 "D" 的一个对象 // 如果未发现，则尝试自动装载类 "D"new \F(); // 创建定义在全局空间中的类 "F" 的一个对象 // 如果未发现，则尝试自动装载类 "F"// 调用另一个命名空间中的静态方法或命名空间函数B\foo(); // 调用命名空间 "A\B" 中函数 "foo"B::foo(); // 调用命名空间 "A" 中定义的类 "B" 的 "foo" 方法 // 如果未找到类 "A\B" ，则尝试自动装载类 "A\B"D::foo(); // 使用导入规则，调用命名空间 "B" 中定义的类 "D" 的 "foo" 方法 // 如果类 "B\D" 未找到，则尝试自动装载类 "B\D"\B\foo(); // 调用命名空间 "B" 中的函数 "foo" \B::foo(); // 调用全局空间中的类 "B" 的 "foo" 方法 // 如果类 "B" 未找到，则尝试自动装载类 "B"// 当前命名空间中的静态方法或函数A\B::foo(); // 调用命名空间 "A\A" 中定义的类 "B" 的 "foo" 方法 // 如果类 "A\A\B" 未找到，则尝试自动装载类 "A\A\B"\A\B::foo(); // 调用命名空间 "A\B" 中定义的类 "B" 的 "foo" 方法 // 如果类 "A\B" 未找到，则尝试自动装载类 "A\B"?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下速查文件]]></title>
      <url>%2F2017%2F03%2F26%2FMac%E4%B8%8B%E9%80%9F%E6%9F%A5%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[对于用 Mac 的小伙伴来说，这是一个非常实用的技能，我花了些时间研究了下，现在写下我的心得。网上一查，主要有两种方法，首先请打开你的终端。 通过Find命令搜索文件find命令来自unix，OS X 和 Linux 系统同样支持该命令。find最基本的语法是：1find 文件路径 选项 目标文件 比如你可以通过以下命令全局搜索名字是 php.ini 的文件:1find / -name &quot;php.ini&quot; 也可以在指定的文件夹中查找以 php 开头的文件：1find ~/Library/ -name &quot;php*&quot; 通过mdfind命令搜索文件mdfind命令就是Spotlight功能的终端界面，mdfind命令非常迅速。最基本的使用方法是：1mdfind -name 文件名 和find一样请务必加上 -name 选项，不加就会搜出一大堆文件。 亲自试了一下这两个方法，速度上 mdfind 快 find 几条街，所以强烈推荐使用 mdfind 。但是使用mdfind -name 文件名和你用Spotlight终端一样是无法搜索被隐藏的文件的。如果你需要搜索隐藏文件，请在终端输入sudo mdfind -name 文件名。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基础]]></title>
      <url>%2F2017%2F03%2F26%2FPHP%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[PHP（全称：Hypertext Preprocessor，即：超文本预处理器”）是一种在服务器上执行的通用开源脚本语言。作为一位 PHP 初学者，决定将一些知识点记录下来。 变量变量变量以 $ 符号开始，后面跟着变量的名称。变量名必须以字母或者下划线字符开始，只能包含字母数字字符以及下划线。PHP变量名和语句一样都是区分大小写的。PHP 有四种不同的变量作用域：local、global、static、parameter。global 关键字用于在函数内部访问全局变量。12345678910111213&lt;?php$x=5;$y=10;function myTest()&#123;global $x,$y;$y=$x+$y;&#125;myTest();echo $y; // 输出 15?&gt; 当一个函数完成时，它的所有变量通常都会被删除。然而，有时候希望某个局部变量不要被删除。static 关键字用于使被标记的变量不被删除。123456789101112&lt;?phpfunction myTest()&#123;static $x=0;echo $x;$x++;&#125;myTest();myTest();myTest();?&gt; 超级全局变量超级全局变量（superglobals）在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。PHP 超级全局变量列表如下: $GLOBALS 一个包含了全部变量的全局组合数组，变量的名字就是数组的键。 $_SERVER 一个包含了诸如头信息(header)、路径(path)等信息的数组。 $_REQUEST 用于收集HTML表单提交的数据。 $_POST 应用于收集表单数据，在form标签的指定属性：”method=”post”。 $_GET 应用于收集表单数据，在form标签的指定属性：”method=”get”。 $_FILES $_ENV $_COOKIE $_SESSION 魔术变量有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 LINE 文件中的当前行号。 FILE 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 DIR 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 FUNCTION 函数名称。 CLASS 类的名称。 TRAIT Trait 的名字。 METHOD 类的方法名。 NAMESPACE 当前命名空间的名称。 常量一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。常量名不需要加 $ 修饰符。常量在定义后，默认是全局变量。设置常量，使用 define() 函数，函数语法如下：1define ( string $name , mixed $value [, bool $case_insensitive = false ] ) 该函数有三个参数: name：必选参数，常量名称，即标志符。 value：必选参数，常量的值。 case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。 echo 和 print 语句两者都是语言结构，输出的字符串可以包含 HTML 标签。echo 和 print 区别: echo 可以输出一个或多个字符串 print 只允许输出一个字符串，返回值总为 1 提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。 函数PHP中的函数不支持重载。函数名、方法名、类名不区分大小写，但推荐使用与定义时相同的名字。任何的默认参数应该放在任何的非默认参数的 右侧 。自PHP5起，默认值可以通过引用传递。从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &amp; ：12345678&lt;?phpfunction &amp; returns_reference ()&#123; return $someref ;&#125;$newref =&amp; returns_reference ();?&gt; 可变函数PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。123456789101112131415&lt;?phpfunction foo () &#123; echo "In foo()&lt;br /&gt;\n" ;&#125;function bar ( $arg = '' ) &#123; echo "In bar(); argument was ' $arg '.&lt;br /&gt;\n" ;&#125;$func = 'foo' ;$func (); // This calls foo()$func = 'bar' ;$func ( 'test' ); // This calls bar()?&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[replace()方法]]></title>
      <url>%2F2017%2F03%2F17%2Freplace-%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。语法 string.replace(searchvalue,newvalue) 参数 描述 searchvalue 必须。规定子字符串或要替换的模式的 RegExp 对象。 newvalue 必须。规定了替换文本或生成替换文本的函数。 简单实例执行一个全局替换, 忽略大小写:123var str="Mr Blue has a blue house and a blue car";var n=str.replace(/blue/gi, "red");console.log(n) 输出结果为：1Mr red has a red house and a red car newvalue 参数为函数newvalue 参数为字符串的情况很简单，但是该参数也可以为函数，该情况下使得 replace() 方法的功能得到巨大提升。 下面这段代码等价于第一个例子：12var n=str.replace(/blue/gi, function()&#123; return "red"&#125;); 上面代码中的匿名函数也可以接受参数，下面是该函数的参数(按参数先后排列)： 形参名 代表的值 match 被匹配的 子字符串 。 $1,$2,… 如果 searchvalue 是正则表达式，则代表第n个小括号匹配的字符串。 offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串时“bc”，那么这个参数将是1） string 被匹配的 原字符串 。 以下例子是很好的说明，代码如下：12345678910var tpl = 'Hello, my name is &lt;%name%&gt;, I am &lt;%age%&gt; years old.'var para = ''function tplEngine(tpl) &#123; tpl.replace(/&lt;%([^%&gt;]+)?%&gt;/g, function(a, b, c, d) &#123; para += '第一个参数：' + a + '， 第二个参数：' + b + '，第三个参数：' + c + '， 第四个参数：' + d + '\n' &#125;) return para&#125;tplEngine(tpl)console.log(para) 以上代码输出如下结果：12第一个参数：&lt;%name%&gt;, 第二个参数：name，第三个参数：18, 第四个参数：Hello, my name is &lt;%name%&gt;, I am &lt;%age%&gt; years old.第一个参数：&lt;%age%&gt;, 第二个参数：age，第三个参数：33, 第四个参数：Hello, my name is &lt;%name%&gt;, I am &lt;%age%&gt; years old. 这样每个参数对应的值就很明显了，并且我们还可以看到：如果 searchvalue 是正则表达式，并且其为全局匹配模式，那么该函数将被多次调用，每次匹配都会被调用。 应用案例利用上述理论基础，我们可以自己做一个简易的模板引擎，代码如下：1234567891011121314151617var data = &#123; 'name': 'Tom', 'age': 28, 'occupation': 'doctor'&#125;var tpl = 'Hello, my name is &lt;%name%&gt;, I am &lt;%age%&gt; years old. My job is &lt;%occupation%&gt;.'function tplEngine(tpl, data) &#123; var text = tpl.replace(/&lt;%([^%&gt;]+)?%&gt;/g, function(a, b) &#123; return data[b] &#125;) return text&#125;var text = tplEngine(tpl, data)console.log(text) 以上代码输出：1Hello, my name is Tom, I am 28 years old. My job is doctor.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS正则表达式2]]></title>
      <url>%2F2017%2F03%2F16%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F2%2F</url>
      <content type="text"><![CDATA[RegExp 对象属性 属性 描述 global RegExp 对象是否具有标志 g ignoreCase RegExp 对象是否具有标志 i multiline RegExp 对象是否具有标志 m source 正则表达式的源文本 lastIndex 一个整数，标示开始下一次匹配的字符位置 lastIndex 语法 RegExpObject.lastIndex该属性存放一个整数，它声明的是上一次匹配文本之后的第一个字符的位置，该属性是可读写。注意：不具有标志 g 和不表示全局模式的 RegExp 对象不能使用 lastIndex 属性。如果在成功地匹配了某个字符串之后就开始检索另一个新的字符串，需要手动地把这个属性设置为 0。 RegExp 对象方法 方法 描述 语法 complie 重新编译正则表达式 RegExpObject.complie(regexp) test 检索字符串中的指定值，返回 true 或 false RegExpObject.test(string) exec 检索字符串中指定的值，返回找到的值，并确定其位置 RegExpObject.exec(string) exec()exec() 方法的功能非常强大，它是一个通用的方法。该方法也非常有用，因此在此详细讲解。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。当 RegExpObject 是一个全局正则表达式时，它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。12345678var str = "Haha!My name is Hanger."; var patt = new RegExp("Ha","g");var result;while ((result = patt.exec(str)) != null) &#123; console.log(result); console.log(patt.lastIndex);&#125; 以上代码输出如下：1234["Ha", index: 0, input: "Haha!My name is Hanger."]2["Ha", index: 16, input: "Haha!My name is Hanger."]18 支持正则表达式的 String 对象的方法 方法 描述 search 检索与正则表达式相匹配的值 match 找到一个或多个正则表达式的匹配 replace 替换与正则表达式匹配的子串 split 把字符串分割为字符串数组 replace 方法在本博客replace()方法一文中有更详细的解释。split 方法在本博客String对象方法一文中有更详细的解释。 分组利用小括号将正则表达式分组，用 $1、$2… 代表每个组。12var date = "2016-11-25".replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g,'$2\/$3\/$1')console.log(date) // 11/25/2016 贪婪模式与非贪婪模式贪婪模式下会比非贪婪模式多匹配字符，使用?表明是非贪婪模式。1234var num = "12345678".replace(/\d&#123;3,6&#125;/g,'X') // 贪婪模式取6个数字console.log(num) // "X78"var num = "12345678".replace(/\d&#123;3,6&#125;?/g,'X') //非贪婪模式取3个数字console.log(num) // "XX78"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS正则表达式]]></title>
      <url>%2F2017%2F03%2F16%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[RegExp 对象RegExp(regular expression) 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。 创建 RegExp 对象12var reg = new RegExp(pattern,modifiers);var reg = /pattern/modifiers; pattern(模式) 描述了表达式的模式 modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配 123/* 注意一个是引号包裹，一个是斜杠包裹，特殊字符需要转义 */var reg = RegExp("^qq\.com$")var reg = / ^qq\.com$ / 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配 m 执行多行匹配 方括号方括号用于查找某个范围内的字符： 表达式 描述 [mhg] 查找方括号之间的任何字符 [^mhg] 查找任何不在方括号之间的字符 [a-z] 查找任何从小写 a 到小写 z 的字符 (mh&#124;g&#124;abc) 查找任何指定的选项 12345var str = "Is this all there is?";var patt1 = /[a-h]/g;console.log(str.match(patt1)); // h,a,h,e,evar patt2 = /(Is|is)/g;console.log(str.match(patt2)); // Is,is,is 元字符元字符（Metacharacter）是拥有特殊含义的字符(以下省略部分生僻元字符)： 元字符 描述 . 所有单个字符，除了换行和行结束符 \w 单词字符 \W 非单词字符 \d 数字字符 \d 非数字字符 \s 空白字符 \S 非空白字符 \b 单词边界 \B 非单词边界 \n 换行符 \r 回车符(与换行符的区别请戳这里) \xxx 以八进制数 xxx 规定的字符 \xdd 以十六进制数 dd 规定的字符 \uxxxx 以十六进制数 xxxx 规定的 Unicode 字符 量词 量词 描述 n+ &gt;=1(至少一个) n* &gt;=0(任意个) n? &lt;=1(至多一个) n{X} X个n n{X,Y} X至Y个n n{X,} 至少X个n n{0,X} 至多X个n n$ 结尾为 n 的字符串 ^n 开头为 n 的字符串 ?=n 其后紧接 n 的字符串 ?!n 其后没有紧接 n 的字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[String对象方法]]></title>
      <url>%2F2017%2F03%2F16%2FString%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[讨论完Array对象的方法，再来讨论一下String对象的方法，两者拥有部分相似的方法：concat()、indexOf()、lastIndexOf()、slice()、valueOf()。这里不再赘述。 提取字符串 substr() 语法string.substr(start,length)。如果start是负数，那么该参数声明从字符串的尾部开始算起的位置。如果 length 为 0 或负数，将返回一个空字符串。 substring() 语法string.substring(start,end)。使用 start 和 end 两者中的较小值作为子字符串的起始点。如果 start 或 end 为 NaN 或者负数，那么将其替换为0。 substr()、substring()、slice() 三者都不改变原数组的值。 字符串转数组 split() 把字符串分割为字符串数组。语法string.split(separator,limit)。返回的数组中的字串不包括 separator 自身。 参数 描述 separator 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 split(&quot;&quot;) 会将 stringObject 中的每个字符之间都分割。split() 会返回完整的字符串，即不做处理。123var str="How are you doing today?";var n=str.split(" "); // 注意这里的分隔符是空格console.log(n) // ["How", "are", "you", "doing", "today?"] 去除空格 trim() 去除字符串两边的空白，不改变原字符串。 注意到该方法只能去除两边的空白，实际工作中我们可能还需要将多个空格合并为一个空格，需要自己拓展：1234String.prototype.ResetBlank = function() &#123; var regEx = /\s+/g; return this.replace(regEx, ' '); &#125;; 大小写转换 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 检索字符与转码 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 formCharCode() 将 Unicode 编码转为字符。 字符串查找与替换 match() 查找正则表达式的匹配，返回一个数组。语法 string.match(regexp) search() 查找正则表达式的匹配项的位置，返回一个数值。语法 string.search(regexp) replace() 在字符串中查找匹配的子串，并替换之。该方法在本博客replace()方法一文中有更详细的解释。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS选择器优先级与效率]]></title>
      <url>%2F2017%2F03%2F15%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E6%95%88%E7%8E%87%2F</url>
      <content type="text"><![CDATA[各类选择器的优先级 important声明 1000 ID选择器 100 类选择器 10 伪类选择器 10 属性选择器 10 标签选择器 1 伪元素选择器 1 通配符选择器 0 属性选择器 = 伪类选择器12a[src^="https"] &#123; color: green; &#125;:last-child &#123; color: red; &#125; 伪类选择器 &gt; 相邻选择器12:last-child &#123; color: green; &#125;p~ul &#123; color: blue; &#125; 相邻选择器 = 子选择器 = 后代选择器123p~ul &#123; color: red; &#125;body &gt; p &#123; color: green; &#125;body p &#123; color: blue; &#125; 后代选择器 &gt; 标签选择器12body p &#123; color: blue; &#125;p &#123; color: green; &#125; 补充 &lt;style&gt;&lt;/style&gt; 同 &lt;link /&gt; 同级，应用取决于&lt;style&gt;标签和&lt;link /&gt; 标签的先后顺序 元素style=&quot;&quot;属性的优先级高于以上两种样式 !important 优先级高于以上两种样式 !important 在IE6中的BUG：在同一组CSS属性中, !important不起作用。1#selector&#123;color:blue !important;color:green;&#125; 选择器效率 ID选择器 类选择器 标签选择器 相邻选择器 子选择器 后代选择器 通配符选择器 属性选择器 伪类选择器 优先级高不一定效率高]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS事件模拟]]></title>
      <url>%2F2017%2F03%2F15%2FJS%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F%2F</url>
      <content type="text"><![CDATA[今天下午去丁香园面试，面试官问我关于事件模拟的问题，我没答上来，回来立马查了资料，实际用到的地方不多，决定粗浅地记录下。 事件通常是在由用户和浏览器进行交互时触发，其实通过 Javascript 也可以在任何时间触发特定的事件。这种能力在测试web应用程序的时候，模拟事件是非常有用的。 事件模拟三步 通过 document.createEvent() 方法创建 event 对象，接收一个参数，即表示要创建的事件类型的字符串： UIEvents：通用的 UI 事件，鼠标事件键盘事件都是继承自UI事件，在 DOM3 级上使用的是 UIEvent 。 MouseEvents：通用的鼠标事件，在 DOM3 级上使用的是 MouseEvent 。 MutationEvents：通用的突变事件，在 DOM3 级上使用的是 MutationEvent 。 HTMLEvents：通用的 HTML 事件，在 DOM3 级上还没有等效的。 在创建了event对象之后，还需要使用与事件有关的信息对其进行初始化。每种类型的event对象都有一个特殊的方法，为它传入适当的数据就可以初始化该event对象。用 event.init……() 此类行的方法。 触发事件。这需要使用 dispatchEvent()方法，接收一个参数，即表示要触发的 event 对象。 实例以模拟鼠标事件为例，首先创建鼠标事件对象的方法 createEvent()传入MouseEvents，返回的对象的方法 initMouseEvent()，接收15个信息： type（字符串）：事件类型如“click”； bubble（布尔值）：是否冒泡； cancelable（布尔值）：是否可取消； view（AbstractView）：与事件关联的视图，一般为document.defaultView； detail（整数）：一般为0，一般只有事件处理程序使用； screenX（整数）：事件相对于屏幕的X坐标； screenY（整数）； clientX（整数）：事件相对于视口的X坐标； clientY（整数）； ctrlKey（布尔值）：是否按下了Ctrl键，默认为false； altKey（布尔值）； shiftKey（布尔值）； metaKey（布尔值）； button（整数）：表示按下了哪个鼠标键，默认为0； relatedTarget（对象）：表示与事件相关的对象。一般只有在模拟mouseover与mouseout时使用。 最后记得把 event 对象传给 dispatchEvent() 方法。代码如下：12345678910111213var btn = document.querySelector("#btn");//创建eventvar event = document.createEvent("MouseEvents");//初始化eventevent.initMouseEvent("click",true,true,document.defaultView,0,0,0,0,0,false,false,false,false,0,null);//click事件绑定事件处理程序btn.onclick = function () &#123; console.log("hello");&#125;//触发事件btn.dispatchEvent(event); //hello//取消引用btn.onclick = null;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Array对象方法]]></title>
      <url>%2F2017%2F03%2F14%2FArray%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在实际的 JavaScript 代码编写中，经常会遇到处理数组的需求，因此在这里罗列一下原生的数组操作方法，常用的方法在前。 头尾增删添加 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 123var arr = [1, 2, 4, 5]console.log(arr.push('2')) // 5console.log(arr) // [1, 2, 4, 5, "2"] 删除 pop() 删除并返回数组的最后一个元素。 shift() 删除并返回数组的第一个元素。 123var arr = [1, 2, 4, 5]console.log(arr.pop()) // 5console.log(arr) // [1,2,4] 局部增删 slice() 选取数组的的一部分，并返回一个新数组。不改变原数组。 splice() 从数组中删除、插入、替换元素，并返回删除的数组。改变原数组。 slice()语法 array.slice(start, end)返回从 start 到 end （ 不包括该元素 ）的数组。 参数 描述 start 可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 splice()这是一个很强大的方法， slice() 能实现的功能它也可以实现，最大的区别是它还可以替换元素，另外这个方法是改变原数组的。语法 array.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。规定从何处开始操作，必须是数字。 howmany 必需。规定应该删除多少元素，必须是数字，可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。 item1, …, itemX 可选。要添加到数组的新元素。 排序数组 reverse() 反转数组的元素顺序。改变原数组。 sort() 对数组的元素进行排序。改变原数组。 这两个方法在本博客JS重排方法一文中有更详细的解释。 遍历数组 every() 检测数值元素的每个元素是否都符合条件。 some() 检测数组元素中是否有元素符合指定条件。 filter() 检测数值元素，并返回符合条件所有元素的数组。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 这四个方法在本博客JS数组迭代一文中有更详细的解释。 连接数组concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。语法 array1.concat(array2,array3,...,arrayX) 分隔数组join() 方法用于把数组中的所有元素转换一个字符串。元素是通过指定的分隔符（默认为逗号）进行分隔的。不改变原数组。语法 array.join(separator) 检索数组 indexOf() 从头到尾搜索，并返回第一个指定项的索引。 lastIndexOf() 从尾到头搜索，并返回第一个指定项的索引。 12array.indexOf(item,start)array.lastIndexOf(item,start) start 是可选参数，规定在数组中开始检索的位置。 类型转换 toString() 把数组转换为字符串，并返回结果。不改变原数组。 valueOf() 返回数组对象的原始值。不改变原数组。 array.toString() 等价于 array.join()123var arr = [1, 2, 4, 5]console.log(arr.valueOf()) // [1, 2, 4, 5]console.log(arr.toString()) // 1,2,4,5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS重排方法]]></title>
      <url>%2F2017%2F03%2F14%2FJS%E9%87%8D%E6%8E%92%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[数组中已经存在两个可以直接用来重排序的方法：reverse() 和 sort() 。 reverse()reverse() 直接颠倒数组的顺序，改变原数组。123var arr = [0, 1, 5, 10, 15]arr.reverse()console.log(arr) // [15, 10, 5, 1, 0] 这个方法的作用很直观，但是很明显不够灵活，因此才有了 sort() 方法。 sort()sort() 方法会先调用每个数组项的 toString() 方法，然后再比较得到的字符串。123var arr = [0, 1, 5, 10, 15]arr.sort()console.log(arr) // [0, 1, 10, 15, 5] 但是这种效果一般都不是我们想要的，sort() 可以接受一个参数，该参数必须是函数，该函数接受两个参数。如果第一个参数应该位于第二个参数之前则返回负值，反之则改为正值。1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1 &#125; else if (value1 &gt; value2) &#123; return 1 &#125; else &#123; return 0 &#125;&#125;arr.sort(compare)console.log(arr) // [0, 1, 5, 10, 15] 对于数值类型可以使用一个更简洁的方法123function compare(value1, value2) &#123; return value1 - value2 // 此为升序，降序则反减 &#125; 值得一提的是，利用 sort() 方法可以用来求数组的极值，极值即为重排序后数组的第一项和最后一项。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS事件委托]]></title>
      <url>%2F2017%2F03%2F12%2FJS%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
      <content type="text"><![CDATA[事件委托是什么事件委托，又叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用 事件冒泡 ，只指定一个事件处理程序，就可以管理某一类型的所有事件。 为什么需要事件委托 在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。如果用事件委托，与 dom 的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。如果用事件委托，那么我们就可以只对它的父级进行操作，这样就需要一个内存空间就够了，提高性能。 事件委托怎么实现123456&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt; 1234567891011121314151617181920212223window.onload = function() &#123; var oBox = document.getElementById("box"); oBox.onclick = function(ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLocaleLowerCase() == 'input') &#123; switch (target.id) &#123; case 'add': alert('添加'); break; case 'remove': alert('删除'); break; case 'move': alert('移动'); break; case 'select': alert('选择'); break; &#125; &#125; &#125;&#125; Event 对象提供了一个属性叫 target ，可以返回事件的目标节点，也就是说，target 就可以表示为当前的事件操作的 dom 。存在兼容性问题，标准浏览器用 ev.target ，IE浏览器用 event.srcElement ，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用 nodeName 来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）。 适用事件适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。不适合的就有很多了，比如 mousemove 每次都要计算它的位置，非常不好把控。还有 focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象数组排序]]></title>
      <url>%2F2017%2F03%2F12%2F%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[网上看到这样一个问题：12345678910var objArr = [&#123; 'a': 999, 'b': 888 &#125;, &#123; 'a': 123, 'b': 345, 'c': 345 &#125;, &#123; 'a': 666 &#125;] 请把以上的对象数组，根据数组每项属性个数的多少排序，使其转化为12345678910var objArr = [&#123; 'a': 666 &#125;,&#123; 'a': 999, 'b': 888 &#125;,&#123; 'a': 123, 'b': 345, 'c': 345 &#125;] 我想了挺久才解决，思路是给每项对象挂上一个新属性(表示对象属性的个数)，再利用 sort() 函数来进行排序，最后把该属性去掉。代码如下1234567891011121314151617181920212223242526272829/*获得对象属性的个数*/Object.prototype.getProperNum = function() &#123; var propNum = 0; for (var i in this) &#123; ++propNum &#125;; return propNum&#125;; /*给对象添加properNum的属性*/for (var i = 0; i &lt; objArr.length; i++) &#123; var num = objArr[i].getProperNum() objArr[i]['properNum'] = num&#125;; /*比较函数*/var compare = function(obj1, obj2) &#123; var val1 = obj1.properNum; var val2 = obj2.properNum; return val1 - val2 //升序&#125; var objArr2 = objArr.sort(compare) for (var i = 0; i &lt; objArr2.length; i++) &#123; delete objArr2[i].proper&#125;; console.log(objArr2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除浮动]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[为什么要清除浮动浮动是魔鬼，会脱离文档流，从而破坏原有的文档结构，最典型的例子就是造成父元素的高度塌陷。 清除浮动的方法清除浮动有多种方法，这里讲三种方法，个人推荐第三种。 添加新元素、定义 clear:both123456&lt;div class="outer"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt; 123456.clear&#123; clear:both; height: 0; line-height: 0; font-size: 0;&#125; 父元素定义 overflow:auto12345&lt;div class="outer clearfix"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt;&lt;/div&gt; 1234.clearfix &#123; overflow: auto; // hidden 也可以 zoom: 1; // 兼容IE&#125; 使用 :after 伪元素1234567891011.clearfix:after &#123; clear: both; content: '.'; display: block; width: 0; height: 0; visibility: hidden;&#125;.clearfix &#123; zoom: 1;&#125; 其中 clear:both; 指清除所有浮动；content:’.’;display:block; 对于FF/chrome/opera/IE8不能缺少，其中 content() 可以取值也可以为空。visibility:hidden; 的作用是允许浏览器渲染它，但不显示出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin负值]]></title>
      <url>%2F2017%2F03%2F12%2Fmargin%E8%B4%9F%E5%80%BC%2F</url>
      <content type="text"><![CDATA[margin 为负值是符合 W3C 标准的，完全没有兼容性问题，另外需要一提的是 padding 和 border 不支持负值。存在就是有意义的，那么负边距究竟有什么样的作用？ 在普通文档流中的效果那些没有脱离文档流的元素，其在页面中的位置是跟随者文档流的变化而变化的。看下面这幅图：现在我们把上图中的块状元素、行内元素以及inline-block元素都设一个负边距 margin:-10px; 看看会发生什么：注意到根据文档流的渲染顺序，前面的元素的会被后面的元素覆盖10px，另外顶部的块状元素也向上隐藏了10px。由此可知，在文档流中，元素的最终边界是由margin决定的，margin为负的时候就相当于元素的边界向里收，文档流只认这个边界，不会管元素的实际尺寸是多少。 对元素宽度的影响如果一个元素未设置宽度(或者width:auto)，负边距能增加元素的宽度。比如下图的黑灰色部分是一个块状元素，它没有设定宽度。它被包裹在一个宽度为400px,且水平居中的父元素中。现在给这个元素的设一个 margin-right:-100px; 对浮动和绝对定位元素的影响浮动元素或者绝对定位的元素会根据元素的边界来定位，而这个边界是由 margin 值来决定的，因此 margin 值的改变会影响元素的位置。 浮动定位利用浮动元素的负边距，可以实现将写在后面的某个元素前置显示。12345678910111213141516171819202122 &lt;style&gt; .ul &gt; div &#123; width: 300px; height: 300px; float: left; &#125; .li1 &#123; background-color: #B7FF7C; &#125; .li2 &#123; background-color: #F9715F; &#125; .li3 &#123; background-color: #83F2FB; margin-left: -450px; &#125; &lt;/style&gt;&lt;div class="ul"&gt; &lt;div class="li1"&gt;list1&lt;/div&gt; &lt;div class="li2"&gt;list2&lt;/div&gt; &lt;div class="li3"&gt;list3&lt;/div&gt; &lt;/div&gt; 效果图如下 绝对定位绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就是 margin 定义的边界，如果margin为负则它的边界是向里收的。利用这点，就有了经典的利用绝对定位来居中的方法。123456789div &#123; position: relative; width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; &#125; 实际应用两栏等高布局1234567891011121314151617181920212223242526272829303132&lt;style&gt;.box &#123; overflow: hidden;&#125;.list1,.list2 &#123; width: 300px; float: left; margin-bottom: -1000px; padding-bottom: 1000px;&#125;.list1 &#123; background-color: #B7FF7C;&#125;.list2 &#123; background-color: #F9715F;&#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="list1"&gt; &lt;p&gt;左列&lt;/p&gt; &lt;p&gt;左列&lt;/p&gt; &lt;p&gt;左列&lt;/p&gt; &lt;/div&gt; &lt;div class="list2"&gt; &lt;p&gt;右列&lt;/p&gt; &lt;p&gt;右列&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 列表去边123456789101112131415161718192021222324252627&lt;style&gt;.box &#123; width: 1200px; margin: auto; background-color: #FEB91E;&#125;.ul &#123; overflow: hidden; margin-right: -20px; // 增大了容器宽度&#125;.li &#123; width: 386.66px; // 计算后的宽度 height: 300px; margin-right: 20px; background-color: #B7FF7C; float: left;&#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="ul"&gt; &lt;div class="li"&gt;list1&lt;/div&gt; &lt;div class="li"&gt;list2&lt;/div&gt; &lt;div class="li"&gt;list3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URL的获取和组装]]></title>
      <url>%2F2017%2F03%2F11%2FURL%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E7%BB%84%E8%A3%85%2F</url>
      <content type="text"><![CDATA[实际开发中，我们会遇到需要处理当前页面 URL 的问题。 获取 URL 参数12345678910111213141516var urlPara = （ function() &#123; var url = window.document.location.href.toString() var urlSlice = url.split('?') if (typeof(urlSlice[1]) == 'string') &#123; urlSlice = urlSlice[1].split('&amp;') var getPara = &#123;&#125; var urlPara = [] for (var i = 0; i &lt; urlSlice.length; i++) &#123; urlPara = urlSlice[i].split('=') getPara[urlPara[0]] = urlPara[1] &#125; return getPara &#125; else &#123; return &#123;&#125; &#125;&#125;）() urlPara 是一个存储了 URL 参数的对象，因此通过 urlPara.属性名 就可得到对应的属性值。 组装 URL 参数1234567function assemblyPara(start,urlPara) &#123; var url = start for(var prop in urlPara)&#123; url += (prop + '=' + urlPara[prop] + '&amp;') &#125; return url&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS数组去重]]></title>
      <url>%2F2017%2F03%2F11%2FJS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
      <content type="text"><![CDATA[数组去重经常在面试中会考到，方法有很多，这里介绍两种方法。12345678910111213141516function unique(array) &#123; if (Array.isArray(array) &amp;&amp; array.length &gt; 0) &#123; var arr = [] for (var i = 0; i &lt; array.length; i++) &#123; if (arr.indexOf(array[i]) == -1) &#123; n.push(array[i]) &#125; &#125; return arr &#125; else &#123; return false &#125;&#125;/*你可以像下面这样调用该函数了*/var arr = [2, 4, 66, 55, 33, 55, 3, 4, 4, 32, 2]console.log(unique(arr)) 第二种方法直接将去重函数挂载在数组原型上，拓展了数组的基本方法，省去了判断参数类型的代码。1234567891011121314Array.prototype.unique = function() &#123; var res = [] var json = &#123;&#125; for (var i = 0; i &lt; this.length; i++) &#123; if (!json[this[i]]) &#123; res.push(this[i]) json[this[i]] = 1 // 传值随意 &#125; &#125; return res &#125;/*你可以像下面这样调用该函数了*/var arr = [2, 4, 66, 55, 33, 55, 3, 4, 4, 32, 2]console.log(arr.unique())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap栅格布局原理]]></title>
      <url>%2F2017%2F03%2F11%2FBootstrap%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[今天有个电话面试问到 Bootstrap 栅格布局的原理，当时没答出来，之后百度了下，发现这个问题我应该答出来的。实现列组合方式非常简单，只涉及两个CSS两个特性：浮动与宽度百分比。123.col-md-1, .col-md-2,... .col-md-11, .col-md-12 &#123; float: left; &#125; 12345678910111213 .col-md-12 &#123; width: 100%; &#125; .col-md-11 &#123; width: 91.66666667%; &#125;... .col-md-2 &#123; width: 16.66666667%; &#125; .col-md-1 &#123; width: 8.33333333%; &#125; 列偏移是通过设置 margin-left 百分比值来实现的。12345678910111213 .col-md-offset-12 &#123; margin-left: 100%;&#125; .col-md-offset-11 &#123; margin-left: 91.66666667%; &#125; ... .col-md-offset-1 &#123; margin-left: 8.33333333%; &#125; .col-md-offset-0 &#123; margin-left: 0; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[换行符和回车符的区别]]></title>
      <url>%2F2017%2F03%2F10%2F%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%92%8C%E5%9B%9E%E8%BD%A6%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[区别换行(\n)就是光标下移一行但不移到这一行的开头，回车(\r)就是回到当前行的开头但不下移一行。按下 Enter 键后会执行 \n\r 。 来历在计算机还没有出现之前，有一种叫做电传打字机的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正 好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。Unix/Mac系统里，每行结尾只有“&lt;换行&gt;”，即”\n”；Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车&gt;”，即“\n\r”。一个直接后果是，Unix/Mac系统下的文件在 Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[null,undefined]]></title>
      <url>%2F2017%2F03%2F09%2Fnull-undefined%2F</url>
      <content type="text"><![CDATA[相似性变量分别被赋值为undefined和null，这两种写法几乎等价。undefined和null在if语句中，都会被自动转为false，相等运算符甚至直接报告两者相等。 区别null 表示一个对象是没有值的，也就是值为“空”；undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； Javascript将未赋值的变量默认值设为undefined，它是用来表明某个用var声明的变量没有值。 typeof undefined //“undefined” undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证null时，一定要使用 === ，因为 == 无法区别 null 和 undefined null == undefined // true null === undefined // false 用法null表示”没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象； 作为对象原型链的终点。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[伪类和伪元素]]></title>
      <url>%2F2017%2F03%2F09%2F%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[伪类种类 伪元素种类 区别这里用伪类 :first-child 和伪元素 :first-letter 来举例说明。 12345p&gt;i:first-child &#123;color: red&#125;&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt; 等价于12345.first-child &#123;color: red&#125;&lt;p&gt; &lt;i class="first-child"&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt; 12p:first-letter &#123;color: red&#125;&lt;p&gt;I am stephen lee.&lt;/p&gt; 等价于12.first-letter &#123;color: red&#125;&lt;p&gt;&lt;span class='first-letter'&gt;I&lt;/span&gt; am stephen lee.&lt;/p&gt; 从例子中可以看到，伪类的效果只需要通过添加一个类名就可以达到，而伪元素的效果需要先添加一个实际的元素再添加一个类名来达到。也就是说， 伪元素需要额外创建一个元素，而伪类不需要 。 CSS3规范伪元素和伪类容易混淆，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。12:Pseudo-classes // 伪类::Pseudo-elements // 伪元素 但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[div居中]]></title>
      <url>%2F2017%2F03%2F09%2Fdiv%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[水平居中定宽水平居中给div设置一个宽度，然后添加margin:0 auto属性。1234div&#123; width:200px; margin:0 auto;&#125; 不定宽水平居中设置 display:table ，这个样式会告知浏览器当前元素的宽度，采用最小的宽度，不是默认全宽。1234div &#123; display:table; margin:0 auto;&#125; 水平垂直居中居中一1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 居中二123456789div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; &#125; 居中三未知容器的宽高，利用 transform 属性123456789div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; &#125; 居中四利用 flex 布局，实际使用时应考虑兼容性。1234567891011.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; height: 100px; background-color: pink; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用markdown语法]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B8%B8%E7%94%A8markdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[列表无序列表1234- 文本1 * 二级文本- 文本2- 文本3 有序列表1231. 文本12. 文本23. 文本3 标题1234# h1## h2### h3... 链接文字链接1[显示文本](链接地址) 自动链接1&lt;http://exmaple.com&gt; 插入图片1234![alt text](图片链接 &quot;title&quot;)![alt text][id] [id]: 图片链接 &quot;title&quot; 引用12345&gt; 引用文字&gt;&gt;&gt; 二级引用文字&gt;&gt; 引用文字 删除线1~~删除线~~ // 不需要空格 注脚12这是一个注脚[^footnote1]的样例[^footnote1]: 我就是那个注脚 表格123456// 不需要对齐dog | bird | cat----|------|-----foo | foo | foobar | bar | barbaz | baz | baz]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS闭包]]></title>
      <url>%2F2017%2F03%2F07%2FJS%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[定义当一个函数可以记住并访问所在的作用域（全局作用域除外），并在定义该函数的作用域之外执行时，该函数就可以称之为一个闭包。简单来说，假设函数A在函数B的内部进行定义了，并在函数B的作用域之外执行（不管是上层作用域，下层作用域，还有其他作用域），那么函数A就是一个闭包。 例子通过闭包，我们可以在其他的执行上下文中， 访问到函数的内部变量 。123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是 闭包的作用域链并不会发生任何改变 。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); setTimeout()闭包题12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 这是一道经典的闭包题，答案是输出5个6，我们要如何修改才能使其输出1~5？ 页面中所有由setTimeout定义的操作，都将放在同一个队列中依次执行。而这个队列执行的时间，需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定。根据setTimeout定义的操作在函数调用栈清空之后才会执行的特点，for循环里定义了5个setTimeout操作。而当这些操作开始执行时，for循环的i值，已经先一步变成了6。因此输出结果总为6。而我们想要让输出结果依次执行，我们就必须借助闭包的特性，每次循环时，将i值保存在一个闭包中，当setTimeout中定义的操作执行时，则访问对应闭包保存的i值即可。因此，我们只需要2个操作就可以完成题目需求，一是使用自执行函数提供闭包条件，二是传入i值并保存在闭包中。12345678for (var i=1; i&lt;=5; i++) &#123; (function(i) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 ); &#125;)(i)&#125; 也可以在setTimeout的第一个参数处利用闭包。 1234567for (var i=1; i&lt;=5; i++) &#123; setTimeout( (function(i) &#123; return function() &#123; console.log(i); &#125; &#125;)(i), i*1000 );&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS原型]]></title>
      <url>%2F2017%2F03%2F07%2FJS%E5%8E%9F%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[JS创建对象在JS中，主要有两种创建对象的方法, 分别是对象字面量以及调用构造函数 12345//对象字面量var obj1 = &#123;&#125; //调用构造函数var obj2 = new Object() prototype 、constructor 每个对象 默认会有一个protoype属性指向它的原型， 构造函数的原型 会有一个consctructor的属性指向构造函数本身，即Person.prototype.constructor === Person __proto__每一个 new出来的实例 都有一个隐式的__proto__属性，指向它们的构造函数的原型，即12person1.__proto__ === Person.constructorperson1.__proto__.constructor === Person 图片说明 Object和Function的关系Object本身是一个构造函数，它也是一个对象，那么Object.__proto__ === Function.prototype Function的 原型属性 与Function的 原型 指向同一个对象，即12Function.__proto__ == Function.prototypetypeof Function.prototype === 'function']]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apply、call、bind]]></title>
      <url>%2F2017%2F03%2F06%2Fapply%E3%80%81call%E3%80%81bind%2F</url>
      <content type="text"><![CDATA[相同点 apply 、call 、bind 三者都是用来改变函数的this对象的指向的； apply 、call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、call 、bind 三者都可以利用后续参数传参； apply 、call在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。123var func = function(arg1, arg2) &#123;&#125;;func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]); 其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。JavaScript 中，某个函数的参数数量是不固定的，因此当你的参数是明确知道数量时用 call 。而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。 数组间追加1234var array1 = [12 , "foo" , &#123;name "Joe"&#125; , -2458]; var array2 = ["Doe" , 555 , 100]; Array.prototype.push.apply(array1, array2); /* array1 值为 [12 , "foo" , &#123;name "Joe"&#125; , -2458 , "Doe" , 555 , 100] */ 求数组极值123var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 minInNumbers = Math.min.apply(Math, numbers); //-215 改造 console.log()1234567function log()&#123; var args = Array.prototype.slice.call(arguments); // 将 arguments 伪数组转化为标准数组 args.unshift('(app)'); // 给每一个 log 消息添加一个 ”(app)” 的前辍 console.log.apply(console, args); &#125;;log(1, 2, 3) // (app) 1 2 3 bindbind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，会以传入 bind()方法的第一个参数作为 this，传入 bind() 方法的之后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。12345678var foo = &#123; bar : 1, eventBind: function()&#123; $('.someClass').on('click',function(event) &#123; console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125; 如果多次调用 bind() ，仍然会输出第一次的结果。在Javascript中，多次 bind() 是无效的。 另外 bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。12345678910111213var obj = &#123; x: 81,&#125;; var foo = &#123; getX: function() &#123; return this.x; &#125;&#125; console.log(foo.getX.bind(obj)()); //81 注意到多一个小括号console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[arguments、callee、caller]]></title>
      <url>%2F2017%2F03%2F03%2Farguments%E3%80%81callee%E3%80%81caller%2F</url>
      <content type="text"><![CDATA[argumentsarguments 是函数调用时，创建的一个伪数组，它存储实际传递给函数的参数。arguments 是一个对象，它有两个常用的属性：length 、callee 。需要注意的是 arguments 并不局限于函数声明的参数列表，举例如下123456function obj()&#123; console.log( 'arguments instanceof Array? ' + (arguments instanceof Array) ); // false console.log( 'arguments instanceof Object? ' + (arguments instanceof Object) ); // true console.log(arguments); // 3&#125;obj('monkey','love',24); calleecallee 是 arguments 对象的一个成员，它的值为“正被执行的Function对象”。arguments.callee 在哪一个函数中运行，它就代表哪一个函数。 一般用在匿名函数中。在匿名函数中有时会需要自己调用自己，但是由于是匿名函数，没有名子，无名可调。这时就可以用arguments.callee来代替匿名的函数。1234(function(n)&#123; if(n &gt; 1) return n* arguments.callee(n-1); return n;&#125;)(10); 上述代码用匿名函数实现的计算10的阶乘。用arguments.calle代替匿名函数。 callercaller 是函数对象的一个属性，该属性保存着调用当前函数的函数。包含闭包，如果没有父函数，则为null。1234567891011121314151617181920212223242526//child是parent内的函数，并在parent内执行childfunction parent()&#123; function child()&#123; console.log( child.caller ); &#125; child();&#125;//parent1没有被别人调用function parent1()&#123; //这里parent1没有父函数 console.log(parent1.caller);&#125;//parent2调用了child2function parent2()&#123; child2();&#125;function child2()&#123; console.log(child2.caller);&#125;/*执行parent里嵌套了child函数parent1没有嵌套函数parent2调用了child2，child2不是嵌套在parent2里的函数*/parent();parent1();parent2(); 在控制台会得到如图结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解BFC]]></title>
      <url>%2F2017%2F03%2F02%2FBFC%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[BFC是什么在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 BoxBox 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。主要有两类盒子： block-level box(块级元素):display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box(内联元素):display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； Formatting contextFormatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 BFC定义BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域， 只有Block-level box参与 ， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫无关系。 BFC生成条件 根元素 position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex float不为none overflow不为visible （ hidden，auto，scroll ） BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于 同一个 BFC的两个 相邻 Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS数组迭代]]></title>
      <url>%2F2017%2F03%2F01%2FJS%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%2F</url>
      <content type="text"><![CDATA[ECMAScript5为数组定义了5个迭代方法，每个方法都接受两个参数：每一项上运行的函数，运行该函数的作用域对象（可选）。 every() 若数组每一项都符合函数要求，返回true，否则返回false some() 若数组任意一项符合函数要求，返回true，否则返回false filter() 对数组每一项运行函数，返回符合函数要求的项组成的数组 map() 对数组每一项运行函数，返回每次函数结果组成的数 forEach() 对数组每一项运行函数，无返回值 实践出真知，以下代码是很好的例子12345678910111213141516171819202122232425262728var numbers = [1,2,3,4,5,4,3,2,1]var everyResult = numbers.every(function (item,index,array) &#123; return (item &gt; 2);&#125;) console.log(everyResult); //false var someResult = numbers.some(function (item,index,array) &#123; return (item&gt;2);&#125;)console.log(someResult); //true var filterResult = numbers.filter(function (item,index,array) &#123; return (item &gt; 2);&#125;) console.log(filterResult); //[3,4,5,4,3]var mapResult = numbers.map(function (item,index,array) &#123; return item*2;&#125;)console.log(mapResult); //[2,4,6,8,10,8,6,4,2]numbers.forEach(function (item,index,array) &#123; console.log(item) //依次输出数组的每一项&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3动画小demo]]></title>
      <url>%2F2017%2F03%2F01%2FCSS3%E5%8A%A8%E7%94%BB%E5%B0%8Fdemo%2F</url>
      <content type="text"><![CDATA[利用css3的动画属性可以实现很多有趣的动画效果。 animation 循环动画animation-iteration-count 属性设置为 infinite 可以使动画循环播放。 loading效果demo1定义一个垂直伸缩的 keyframes ，然后绑定在每个条子上，设置不同的animation-delay，就可以使每个条子运动起来，整体成波浪线运动。当网页中有需要等待的请求时，我们就可以插入这段动画，优化用户体验。 摆钟效果demo2这个 demo 用到了 transform-origin 属性，将钟表和秒针的旋转中心设置在不同的地方，利用相对定位和绝对相对，使秒钟旋转中心根据钟表的位置定位，从而使钟表做钟摆运动的同时，秒钟做圆周运动。再将 animation-direction 属性值设为 alternate ，使钟表来回运动。 transition 过渡动画transition 属性和 :hover 联用实现酷炫的动态效果。 朦层效果demo3鼠标移到图片上，边框旋转180度，显示朦层和字体，鼠标移出还原。朦层和字体在同一个 div 下，该 div 和边框 div 都设置 position:absolute ，最外层 div 设置 position:relative 。该效果可以用于图片信息的展示。 折角效果demo4鼠标移到图片上，显示折角，点击折角图片消失显示按钮，点击小叉叉图片又动态地恢复。利用 before 伪类创建折角，初始 border-width: 0;，当鼠标移入时设置 border-right-width: 80px;border-bottom-width: 80px; ，为了使折角两边颜色不一样设置 border-color: rgba(0, 0, 0, 0.2) #fff;。该效果可用于图片的翻页。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3转换过渡动画]]></title>
      <url>%2F2017%2F03%2F01%2FCSS3%E8%BD%AC%E6%8D%A2%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[CSS3中有三个属性：transform、transition、animation，一直容易搞混，今天特意拎出来理一理。 transform 转换transform 能够对元素进行移动、缩放、转动、拉长或拉伸。transform 分为2D转换和3D转换，由于目前浏览器对3D转换的支持度还不好，所以以下主要讲解2D转换。 2D转换方法 translate(x,y) 移动，参数为像素值 translateX(n) translateY(n) rotate(angle) 转动，参数为角度 scale(x,y) 缩放，参数为倍数 scaleX(n) scaleY(n) skew(x-angle,y-angle) 倾斜，参数为角度 skewX(angle) skewY(angle) matrix() 参数为六个值的矩阵，可以描述以上所有转换，用于复杂的转换 transform-origin另外，还有一个transform-origin属性，用来改变被转换元素的位置，一般和rotate()配合使用。1234567891011121314151617div&#123;transform: rotate(45deg);transform-origin:20% 40%;-ms-transform: rotate(45deg); /* IE 9 */-ms-transform-origin:20% 40%; /* IE 9 */-webkit-transform: rotate(45deg); /* Safari 和 Chrome */-webkit-transform-origin:20% 40%; /* Safari 和 Chrome */-moz-transform: rotate(45deg); /* Firefox */-moz-transform-origin:20% 40%; /* Firefox */-o-transform: rotate(45deg); /* Opera */-o-transform-origin:20% 40%; /* Opera */&#125; transform-origin的参数可以为：left、right、center、length、% 。 transition 过渡该属性和 :hover 配合使用，实现鼠标移入动画效果。要实现过渡，必须规定两项内容： 规定您希望把效果添加到哪个 CSS 属性上 规定效果的时长 过渡属性 属性 描述 transition 简写属性，在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 实例123456789101112131415161718div&#123;width:100px;height:100px;background:yellow;transition-property:width 1s linear 2s;/* Firefox 4 */-moz-transition:width 1s linear 2s;/* Safari and Chrome */-webkit-transition:width 1s linear 2s;/* Opera */-o-transition:width 1s linear 2s;&#125;div:hover&#123;width:200px;&#125; animation 动画该属性和 @keyframes 配合使用。 @keyframes@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。1234567891011121314151617181920212223@keyframes myfirst&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125; @keyframes中也可以用具体的百分比1234567@keyframes myfirst&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125; 在 @keyframes 中创建动画，把它捆绑到某个选择器，否则不会产生动画效果。通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长1234567div&#123;animation: myfirst 5s;-moz-animation: myfirst 5s; /* Firefox */-webkit-animation: myfirst 5s; /* Safari 和 Chrome */-o-animation: myfirst 5s; /* Opera */&#125; 动画属性 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 animation-delay 规定动画何时开始。默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js基础3]]></title>
      <url>%2F2017%2F02%2F28%2FVue-js%E5%9F%BA%E7%A1%803%2F</url>
      <content type="text"><![CDATA[自定义指令除了默认设置的核心指令( v-model 和 v-show ), Vue 也允许注册自定义指令。注册全局指令的关键方法是directive(),注册局部指令的关键方法是directives（） 钩子函数指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。unbind: 只调用一次， 指令与元素解绑时调用。 钩子函数的参数钩子函数的参数有： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 路由Vue.js 路由允许我们通过不同的 URL 访问不同的内容。Vue.js 路由需要载入 vue-router 库。12345678910111213141516&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter) // 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125; // 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;] // 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;) // 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js基础2]]></title>
      <url>%2F2017%2F02%2F28%2FVue-js%E5%9F%BA%E7%A1%802%2F</url>
      <content type="text"><![CDATA[继续组件的内容，接下来是 vue 组件的重要内容。 父子组件子组件只能在父组件中只用，写在html中的是父组件的标签。使用组件有三步：定义，注册，创建根实例。以下代码是很好的例子：123456789101112131415161718192021&lt;div id="example"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; //定义组件 var child = Vue.extend(&#123; template: "&lt;div&gt;this is a child component!&lt;/div&gt;" &#125;) var parent = Vue.extend(&#123; template: "&lt;div&gt;this is a parent component! &lt;child&gt;&lt;/child&gt;&lt;/div&gt;", components: &#123; 'child': child &#125; &#125;) //注册组件 Vue.component('my-component', parent) //创建根实例 new Vue(&#123; el:'#example' &#125;)&lt;/script&gt; 组件选项问题传入 Vue 构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例： data 和 el。如果我们简单地把一个对象作为 data 选项传给 Vue.extend（）， 所有的实例将共享同一个 data 对象！这基本不是我们想要的，因此我们应当使用一个函数作为 data 选项，让这个函数返回一个新对象：123456var child = Vue.extend(&#123; template: "&lt;div&gt;this is a child component!&lt;/div&gt;" data : function () &#123; return &#123;a:1&#125; &#125;&#125;) 同理，el 选项用在 Vue.extend() 中时也须是一个函数。 Props组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。“prop” 是组件数据的一个字段，期望从父组件传下来。子组件需要显式地用 props 选项 声明 props，同时可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：123456789101112131415161718192021&lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:message="parentMsg"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;Vue.component('child', &#123; // 声明 props props: ['message'], template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data: &#123; parentMsg: '父组件内容' &#125;&#125;)&lt;/script&gt; 子组件中：props:[&#39;key&#39;]父组件中：key：&#39;value&#39;从而做到将父组件中的数据传给子组件。注意:prop是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。 自定义事件你现在肯定很想知道，那么子组件怎么把数据给父组件呢？方法就是自定义事件！使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。以下实例中子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.component('button-counter', &#123; template: '&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; increment是自定义事件，$emit()触发事件，父组件中v-on监听了该事件，并挂载了事件响应程序，当子组件中increment事件被触发，父组件能捕捉到并触发对应的响应程序。通过响应程序来改变父组件中的数据，也就是说，最后改变父组件中的数据需要通过父组件中的methods，子组件只是通过自定义事件触发了父组件中的响应程序。 而父组件向子组件传递数据则是通过子组件的props属性值联系在一起的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js基础]]></title>
      <url>%2F2017%2F02%2F28%2FVue-js%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[引言一开始接触vue的时候老实说我是一脸懵逼的，一下子还没从jQuery的思维中解脱出来，因此研究了好久的，过了一段时间后，再翻开vue的文档，总算是有些眉目了，现在记录下自己的理解吧，有写的不对的地方欢迎指正。这里只记录了我个人的理解，要详细的推荐Vue官方文档。 我理解的vue核心思想1.视图参数化，数据驱动视图view(DOM节点)的属性被参数化，参数化的值被记录在Vue实例的data属性中，当通过methods中的函数改变data中的数据时，view也会发生变化，从而达到数据驱动视图的作用。2.DOM结构组件化组件化的思想提高了DOM结构的复用性，使搭架复杂的DOM结构更加简单快捷。组件需要先注册Vue.component(tagName, options) 注册后就可以在HTML文档中直接使用了&lt;tagName&gt;&lt;/tagName&gt; v-bind、v-onv-bind：的缩写为 ：用来绑定元素的属性，属性的值被记录在Vue.data中v-on：的缩写为 @ 用来绑定元素的事件，事件响应程序被记录在Vue.methods中 12345&lt;div v-bind:class="[red,blue ? 'blue' : 'green']" v-on:click='changeColor'&gt;&lt;/div&gt;...changeColor:function () &#123; this.blue = !this.blue&#125; computedcomputed是基于依赖的缓存，当重新渲染时，methods中的函数会被重新调用，而computed中的函数在依赖不变的情况下不会被调用 v-modelv-model用在表单中，实现双向数据绑定。1234567891011121314151617&lt;div id="app"&gt; &lt;p&gt;input 元素：&lt;/p&gt; &lt;input v-model="message" placeholder="编辑我……"&gt; &lt;p&gt;消息是: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;textarea 元素：&lt;/p&gt; &lt;p style="white-space: pre"&gt;&#123;&#123; message2 &#125;&#125;&lt;/p&gt; &lt;textarea v-model="message2" placeholder="多行文本输入……"&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'Runoob', message2: '菜鸟教程\r\nhttp://www.runoob.com' &#125;&#125;)&lt;/script&gt; 用户更改表单中的输入，会改变视图层的显示。 .lazy在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：1&lt;input v-model.lazy="msg" &gt; .number如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：1&lt;input v-model.number="age" type="number"&gt; .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：1&lt;input v-model.trim="msg"&gt; 组件全局组件12345678910111213&lt;div id="app"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt;&lt;script&gt;// 注册Vue.component('runoob', &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 局部组件123456789var Child = &#123; template:'&lt;h1&gt;自定义组件&lt;/h1&gt;'&#125;new Vue(&#123; el:'#app', components:&#123; 'runoob':Child &#125;&#125;)]]></content>
    </entry>

    
  
  
</search>
